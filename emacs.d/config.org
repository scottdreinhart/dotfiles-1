#+TITLE: Emacs Configuration file
#+AUTHOR: Peng Li
#+EMAIL: seudut@gmail.com

* Introduction

Most config are just copied from [[https://github.com/howardabrams/dot-files][howardabrams]]'s and [[https://github.com/abo-abo/oremacs][abo-abo's]] dotfiles

* Basic Settings
** Setting loading Path

Set system PATH and emacs exec path

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (setenv "PATH" (concat (getenv "PATH")
                         ":" "/usr/local/bin"
                         ":" "/Library/TeX/texbin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))
  (setq exec-path (append exec-path '("/Library/TeX/texbin/")))

#+END_SRC

Set the emacs load path

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (add-to-list 'load-path "~/.emacs.d/elisp")
#+END_SRC

** Package Initialization

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (require 'package)

  (setq package-archives '(("mepla" . "http://melpa.milkbox.net/packages/")
                           ("gnu" . "http://elpa.gnu.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")))

  (package-initialize)

#+END_SRC       

** General Setting
*** scroll bar, tool-bar and menu-bar
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 1)

  ;; (setq debug-on-error t)
  (setq inhibit-startup-message t)

  (defalias 'yes-or-no-p 'y-or-n-p)
  (show-paren-mode 1)
  ;; don't backupf
  (setq make-backup-files nil)
#+END_SRC

*** Custom file 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent 
  (setq custom-file "~/.emacs.d/custom.el")
  (if (file-exists-p custom-file)
      (load custom-file))
#+END_SRC

*** Switch the focus to help window when it appears
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq help-window-select t)
#+END_SRC

*** Set default window size
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq initial-frame-alist
        '((width . 120)
          (height . 50)))
#+END_SRC

*** Stop auto save
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq auto-save-default nil)

  ;; restore last session
  ;; (desktop-save-mode t)
#+END_SRC

*** Save minibuffer history
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (savehist-mode 1)
  (setq history-length 1000)
#+END_SRC

*** temp folder
Make a temp directory for all cache/history files
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defconst sd-temp-directory
    (file-name-as-directory "~/.emacs.d/temp"))

  (unless (file-exists-p sd-temp-directory)
    (mkdir sd-temp-directory))
#+END_SRC

* Package Management Tools

** Use-package

Using [[https://github.com/jwiegley/use-package][use-package]] to manage emacs packages

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)

#+END_SRC

** El-get

[[https://github.com/dimitri/el-get][El-get]] is package management tool, whicl allows to install external elisp package from any git repository not in mepla. 
Check out [[http://tapoueh.org/emacs/el-get.html][el-get]].

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package el-get
    :ensure t
    :init
    (add-to-list 'load-path "~/.emacs.d/el-get"))

#+END_SRC

* Color and Fonts Settings

** highlight current line

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (global-hl-line-mode)

#+END_SRC

** Smart Comments

[[https://github.com/paldepind/smart-comment][smart-comments]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package smart-comment
    :ensure t
    :bind ("M-;" . smart-conmment))

#+END_SRC

** Font Setting

syntax highlighting

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (global-font-lock-mode 1)

#+END_SRC

[[https://github.com/i-tu/Hasklig][Hasklig]] and Source Code Pro, defined fonts family

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (if window-system
      (defvar sd/fixed-font-family
        (cond ((x-list-fonts "Hasklig")         "Hasklig")
              ((x-list-fonts "Source Code Pro") "Source Code Pro:weight:light")
              ((x-list-fonts "Anonymous Pro")   "Anonymous Pro")
              ((x-list-fonts "M+ 1mn")          "M+ 1mn"))
        "The fixed width font based on what is installed, `nil' if not defined."))

#+END_SRC

Setting the fonts 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (if window-system
      (when sd/fixed-font-family
        (set-frame-font sd/fixed-font-family)
        (set-face-attribute 'default nil :font sd/fixed-font-family :height 130)
        (set-face-font 'default sd/fixed-font-family)))

#+END_SRC

** Color Theme

Loading theme should be after all required loaded, refere [[https://github.com/jwiegley/use-package][:defer]] in =use-package=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (setq vc-follow-symlinks t)

  (use-package color-theme
    :ensure t
    :init (require 'color-theme)
    :config (use-package color-theme-sanityinc-tomorrow
              :ensure t
              :no-require t
              :config
              (load-theme 'sanityinc-tomorrow-bright t)))

  ;(eval-after-load 'color-theme
  ;  (load-theme 'sanityinc-tomorrow-bright t))

#+END_SRC

Change the Org-mode colors 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun org-src-color-blocks-light ()
    "Colors the block headers and footers to make them stand out more for lighter themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line
      ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
     '(org-block-background
       ((t (:background "#FFFFEA"))))
     '(org-block
       ((t (:background "#FFFFEA"))))
     '(org-block-end-line
       ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))

     '(mode-line-buffer-id ((t (:foreground "#005000" :bold t))))
     '(which-func ((t (:foreground "#008000"))))))

  (defun org-src-color-blocks-dark ()
    "Colors the block headers and footers to make them stand out more for dark themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line
       ((t (:foreground "#008ED1" :background "#002E41"))))
     '(org-block-background
       ((t (:background "#000000"))))
     '(org-block
       ((t (:background "#000000"))))
     '(org-block-end-line
       ((t (:foreground "#008ED1" :background "#002E41"))))

     '(mode-line-buffer-id ((t (:foreground "black" :bold t))))
     '(which-func ((t (:foreground "green"))))))

  (org-src-color-blocks-dark)

#+END_SRC

improve color for org-mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (deftheme ha/org-theme "Sub-theme to beautify org mode")

  (if window-system
      (defvar sd/variable-font-tuple
        (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
              ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
              ((x-list-fonts "Verdana")         '(:font "Verdana"))
              ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
              (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro.")))
        "My variable width font available to org-mode files and whatnot."))

  (defun sd/org-color ()
    (let* ((sd/fixed-font-tuple (list :font sd/fixed-font-family))
           (base-font-color     (face-foreground 'default nil 'default))
           (background-color    (face-background 'default nil 'default))
           (primary-color       (face-foreground 'mode-line nil))
           (secondary-color     (face-background 'secondary-selection nil 'region))
           (base-height         (face-attribute 'default :height))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces 'ha/org-theme
                              `(org-agenda-structure ((t (:inherit default :height 2.0 :underline nil))))
                              `(org-verbatim ((t (:inherit 'fixed-pitched :foreground "#aef"))))
                              `(org-table ((t (:inherit 'fixed-pitched))))
                              `(org-block ((t (:inherit 'fixed-pitched))))
                              `(org-block-background ((t (:inherit 'fixed-pitched))))
                              `(org-block-begin-line ((t (:inherit 'fixed-pitched))))
                              `(org-block-end-line ((t (:inherit 'fixed-pitched))))
                              `(org-level-8 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-7 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-6 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-5 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-4 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.1 base-height))))))
                              `(org-level-3 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.25 base-height))))))
                              `(org-level-2 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.5 base-height))))))
                              `(org-level-1 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.75 base-height))))))
                              `(org-document-title ((t (,@headline ,@sd/variable-font-tuple :height 1.5 :underline nil)))))))


#+END_SRC

** Rainbow-delimiter

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

#+END_SRC

** page-break-lines

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package page-break-lines
    :ensure t
    :config
    (turn-on-page-break-lines-mode))

#+END_SRC

** rainbow-mode

Enable rainbow mode in emacs lisp mode

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package rainbow-mode
    :ensure t
  ;  :init
  ;  (add-hook emacs-lisp-mode-hook 'rainbow-mode)
    )

#+END_SRC

* Mode-line

** clean mode line

clean mode line, Refer to [[https://www.masteringemacs.org/article/hiding-replacing-modeline-strings][Marstering Emacs]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defvar mode-line-cleaner-alist
    `((auto-complete-mode . " α")
      (yas/minor-mode . " υ")
      (paredit-mode . " π")
      (eldoc-mode . "")
      (abbrev-mode . "")
      (projectile-mode . "")
      (ivy-mode . "")
      (undo-tree-mode . "")
      ;; default is WK
      (which-key-mode . "")
      ;; default is SP
      (smartparens-mode . "")
      ;; default is LR
      (linum-relative-mode . "")
      ;; default is ARev
      (auto-revert-mode . "")
      ;; default is Ind
      (org-indent-mode . "")
      ;; default is  Fly
      (flyspell-mode . "")
      ;; Major modes
      (lisp-interaction-mode . "λ")
      (hi-lock-mode . "")
      (python-mode . "Py")
      (emacs-lisp-mode . "EL")
      (eshell-mode . "ε")
      (nxhtml-mode . "nx"))
    "Alist for `clean-mode-line'.

  When you add a new element to the alist, keep in mind that you
  must pass the correct minor/major mode symbol and a string you
  want to use in the modeline *in lieu of* the original.")


  (defun clean-mode-line ()
    (interactive)
    (loop for cleaner in mode-line-cleaner-alist
          do (let* ((mode (car cleaner))
                   (mode-str (cdr cleaner))
                   (old-mode-str (cdr (assq mode minor-mode-alist))))
               (when old-mode-str
                   (setcar old-mode-str mode-str))
                 ;; major mode
               (when (eq mode major-mode)
                 (setq mode-name mode-str)))))


  (add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+END_SRC

** Powerline mode

Install powerline mode [[https://github.com/milkypostman/powerline][powerline]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package powerline
    :ensure t
    :config
    ;; (powerline-center-theme)
    )

  ;; (use-package smart-mode-line
  ;;   :ensure t)
  ;; (use-package smart-mode-line-powerline-theme
  ;;   :ensure t)
#+END_SRC

Revised powerline-center-theme
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/powerline-simpler-vc (s)
    (if s
        (replace-regexp-in-string "Git[:-]" "" s)
      s))

  (defface sd/powerline-active1 '((t (:background "yellow" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/buffer-modified-active1 '((t (:background "red" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/buffer-view-active1 '((t (:background "green" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/mode-line-buffer-id
    '((t (:background "yellow" :foreground "black" :inherit mode-line-buffer-id)))
    "My powerline mode-line face, based on mode-line-buffer-id"
    :group 'powerline)

  ;; Don't show buffer modified for scratch and eshell mode
  (defun sd/buffer-show-modified ()
    "Dot not show modified indicator for buffers"
    (interactive)
    (unless (or (string-match "*scratch*" (buffer-name))
                (equal major-mode 'eshell-mode))
      t))

  (defun sd/powerline-center-theme_revised ()
    "Setup a mode-line with major and minor modes centered."
    (interactive)
    (setq-default mode-line-format
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (mode-line-buffer-id (if active 'sd/mode-line-buffer-id 'mode-line-buffer-id-inactive))
                            (mode-line (if active 'mode-line 'mode-line-inactive))
                            (my-face1 (if active 'sd/powerline-active1 'powerline-inactive1))
                            (my-face-buffer-modified (if (and (sd/buffer-show-modified) (buffer-modified-p)) 
                                                         'sd/buffer-modified-active1
                                                       (if buffer-read-only 'sd/buffer-view-active1
                                                         my-face1)))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (separator-left (intern (format "powerline-%s-%s"
                                                            (powerline-current-separator)
                                                            (car powerline-default-separator-dir))))
                            (separator-right (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (cdr powerline-default-separator-dir))))
                            (lhs (list (powerline-raw "%* " my-face-buffer-modified 'l)
                                       ;; (powerline-buffer-size mode-line 'l)
                                       (powerline-buffer-id mode-line-buffer-id 'l)
                                       (powerline-raw " " my-face1)
                                       (funcall separator-left my-face1 face1)
                                       (powerline-narrow face1 'l)
                                       ;; (powerline-vc face1)
                                       (sd/powerline-simpler-vc (powerline-vc face1))))
                            (rhs (list (powerline-raw global-mode-string face1 'r)
                                       (powerline-raw "%4l" face1 'r)
                                       (powerline-raw ":" face1)     
                                       (powerline-raw "%3c" face1 'r)
                                       (funcall separator-right face1 my-face1)
                                       ;; (powerline-raw " " my-face1)
                                       (powerline-raw (format-time-string " %I:%M %p  ") my-face1 'r)
                                       ;; (powerline-raw "%6p" my-face1 'r)
                                       ;; (powerline-hud my-face1 face1 )
                                       ))
                            (center (list (powerline-raw " " face1)
                                          (funcall separator-left face1 face2)
                                          (when (and (boundp 'erc-track-minor-mode) erc-track-minor-mode)
                                            (powerline-raw erc-modified-channels-object face2 'l))
                                          (powerline-major-mode face2 'l)
                                          (powerline-process face2)
                                          (powerline-raw " :" face2)
                                          (powerline-minor-modes face2 'l)
                                          (powerline-raw " " face2)
                                          (funcall separator-right face2 face1))))
                       (concat (powerline-render lhs)
                               (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                               (powerline-render center)
                               (powerline-fill face1 (powerline-width rhs))
                               (powerline-render rhs)))))))

  (sd/powerline-center-theme_revised)
#+END_SRC

Fix the issue in mode line when showing triangle 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq ns-use-srgb-colorspace nil)
#+END_SRC

set height in mode line
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (set-variable 'powerline-height 14)
  (set-variable 'powerline-text-scale-factor (/ (float 100) 140))
  ;; (custom-set-variables
  ;;  '(powerline-height 14)
  ;;  '(powerline-text-scale-factor (/ (float 100) 140)))
  ;; 100/140;0.8
  (set-face-attribute 'mode-line nil :height 100)
#+END_SRC

* IDO & SMEX

** IDO

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package ido
    :ensure t
    :init (setq ido-enable-flex-matching t
                ido-ignore-extensions t
                ido-use-virtual-buffers t
                ido-everywhere t)
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (add-to-list 'completion-ignored-extensions ".pyc"))

  (icomplete-mode t)

#+END_SRC

** FLX

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package flx-ido
    :ensure t
    :init (setq ido-enable-flex-matching t
                ido-use-faces nil)
    :config (flx-ido-mode 1))

#+END_SRC

** IDO-vertically
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido-vertical-mode
    :ensure t
    :init
    (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
    :config
    (ido-vertical-mode 1))
#+END_SRC

** SMEX

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package smex
    :ensure t
    :init (smex-initialize)
    :bind
    ("M-x" . smex)
    ("M-X" . smex-major-mode-commands))

#+END_SRC

** Ido-ubiquitous

Use [[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] for ido everywhere. It makes =describe-function= can also use ido

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package ido-ubiquitous
    :ensure t
    :init
    (setq magit-completing-read-function 'magit-ido-completing-read)
    (setq gnus-completing-read-function 'gnus-ido-completing-read)
    :config
    (ido-ubiquitous-mode 1))

#+END_SRC

** Ido-exit-target
[[https://github.com/waymondo/ido-exit-target][ido-exit-target]] let you open file/buffer on =other-windows= when call =ido-switch-buffer=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido-exit-target
    :ensure t
    :init
    (mapcar (lambda (map)
              (define-key map (kbd "C-j") #'ido-exit-target-split-window-right)
              (define-key map (kbd "C-k") #'ido-exit-target-split-window-below))
            (list ido-buffer-completion-map
                  ;; ido-common-completion-map
                  ido-file-completion-map
                  ido-file-dir-completion-map)))
#+END_SRC

* Normal Text Operation
** Edit
*** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package undo-tree
    :ensure t
    :config
    (define-key undo-tree-visualizer-mode-map "j" 'undo-tree-visualize-redo)
    (define-key undo-tree-visualizer-mode-map "k" 'undo-tree-visualize-undo)
    (define-key undo-tree-visualizer-mode-map "h" 'undo-tree-visualize-switch-branch-left)
    (define-key undo-tree-visualizer-mode-map "l" 'undo-tree-visualize-switch-branch-right)
    (global-undo-tree-mode 1))

  (global-set-key (kbd "s-u") 'undo-tree-visualize)
#+END_SRC

*** flyspell
Stolen from [[https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el][here]], hunspell will search dictionary in =DICPATH=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setenv "DICPATH" "/usr/local/share/hunspell")

  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  ;; (defun text-mode-hook-setup ()
  ;;   ;; Turn off RUN-TOGETHER option when spell check text-mode
  ;;   (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
  ;; (add-hook 'text-mode-hook 'text-mode-hook-setup)
  ;; (add-hook 'text-mode-hook 'flyspell-mode)

  ;; enable flyspell check on comments and strings in progmamming modes
  ;; (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  ;; I don't use the default mappings
  (with-eval-after-load 'flyspell
    (define-key flyspell-mode-map (kbd "C-;") nil)
    (define-key flyspell-mode-map (kbd "C-,") nil)
    (define-key flyspell-mode-map (kbd "C-.") nil))
#+END_SRC

Make flyspell enabled for org-mode, see [[http://emacs.stackexchange.com/questions/9333/how-does-one-use-flyspell-in-org-buffers-without-flyspell-triggering-on-tangled][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; NO spell check for embedded snippets
  (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
    (let ((rlt ad-return-value)
          (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
          (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
          old-flag
          b e)
      (when ad-return-value
        (save-excursion
          (setq old-flag case-fold-search)
          (setq case-fold-search t)
          (setq b (re-search-backward begin-regexp nil t))
          (if b (setq e (re-search-forward end-regexp nil t)))
          (setq case-fold-search old-flag))
        (if (and b e (< (point) e)) (setq rlt nil)))
      (setq ad-return-value rlt)))
#+END_SRC

*** Expand-region
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

* Key bindings

** Esc on Minibuffer

Use =ESC= to exit minibuffer. Also I map =Super-h= the same as =C-g=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (define-key minibuffer-local-map [escape] 'keyboard-escape-quit)
  (define-key minibuffer-local-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-ns-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-isearch-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-completion-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-must-match-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-must-match-filename-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-filename-completion-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-filename-must-match-map [escape]  'keyboard-escape-quit)

  ;; Also map s-h same as C-g
  (define-key minibuffer-local-map (kbd "s-h") 'keyboard-escape-quit)

#+END_SRC

** Search Replace and highlight
*** swiper
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (use-package swiper
  ;;   :ensure t)

  ;; (ivy-mode 1)
  ;; (setq ivy-use-virtual-buffers t)
  ;; (global-set-key (kbd "s-/") 'swiper)

  (use-package counsel
    :ensure t
    :defer t)
  ;;* 
  ;; (global-set-key "\C-s" 'swiper)
  ;; (global-set-key (kbd "C-c C-r") 'ivy-resume)
  ;; (global-set-key (kbd "<f6>") 'ivy-resume)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  ;; ;; (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "C-h f") 'counsel-describe-function)
  (global-set-key (kbd "C-h v") 'counsel-describe-variable)
  ;; (global-set-key (kbd "<f1> l") 'counsel-load-library)
  ;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  ;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  ;; (global-set-key (kbd "C-c g") 'counsel-git)
  ;; (global-set-key (kbd "C-c j") 'counsel-git-grep)
  ;; (global-set-key (kbd "C-c k") 'counsel-ag)
  ;; (global-set-key (kbd "C-x l") 'counsel-locate)
  ;; (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
  ;; ;; (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)

  ;; (set-face-attribute
  ;;  'ivy-current-match nil
  ;;  :background "Orange"
  ;;  :foreground "black")

  ;; ivy-resume
  ;; (define-key swiper-map (kbd "M-%") 'swiper-aa-replace)
#+END_SRC

*** =M-s= prefix
use the prefix =M-s= for searching in buffers
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/make-keymap (key bindings)
    (setq keymap (make-sparse-keymap))
    (dolist (binding bindings)
      (define-key keymap (car binding) (cdr binding)))
    (global-set-key key keymap))

  (use-package highlight-symbol
    :ensure t)

  (sd/make-keymap "\M-s"
                  '(("w" . save-buffer)
                    ;; ("\M-w" . save-buffer)
                    ("e" . revert-buffer)
                    ("s" . isearch-forward-regexp)
                    ("\M-s" . isearch-forward-regexp)
                    ("r" . isearch-backward-regexp)
                    ("." . isearch-forward-symbol-at-point)
                    ("o" . occur)
                    ;; ("h" . highlight-symbol-at-point)
                    ("h" . highlight-symbol)
                    ("m" . highlight-regexp)
                    ("l" . highlight-lines-matching-regexp)
                    ("M" . unhighlight-regexp)
                    ("f" . keyboard-quit)
                    ("q" . keyboard-quit)))

  ;; search and replace and highlight
  (define-key isearch-mode-map (kbd "M-s") 'isearch-repeat-forward)
  (define-key isearch-mode-map (kbd "M-r") 'isearch-repeat-backward)
  (global-set-key (kbd "s-[") 'highlight-symbol-next)
  (global-set-key (kbd "s-]") 'highlight-symbol-prev)
  (global-set-key (kbd "s-\\") 'highlight-symbol-query-replace)


  (define-key minibuffer-local-map "\M-s" nil)

  (set-face-background 'ido-first-match "yellow")

  ;; M-s M-w              eww-search-words

  ;; M-c
  ;; M-r
  ;; M-t
  ;; M-u, 
#+END_SRC

* Org-mode Settings

** Org-mode Basic setting

Always indents header, and hide header leading starts so that no need type =#+STATUP: indent= 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org
    :ensure t
    :init
    (setq org-startup-indented t)
    (setq org-hide-leading-starts t)
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-use-speed-commands t)
    (setq org-completion-use-ido t))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (C . t)
     (perl . t)
     (calc . t)
     (latex . t)
     (java . t)
     (ruby . t)
     (lisp . t)
     (scheme . t)
     (sh . t)
     (sqlite . t)
     (js . t)
     (gnuplot . t)
     (ditaa . t)))

  ;; use current window for org source buffer editting
  (setq org-src-window-setup 'current-window )

  (define-key org-mode-map (kbd "C-'") nil)
  ;; C-M-i is mapped to imenu globally
  (define-key org-mode-map (kbd "C-M-i") nil)

  ;; set the ditta.jar path
  (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
  (unless 
      (file-exists-p org-ditaa-jar-path)
    (error "seudut: ditaa.jar not found at %s " org-ditaa-jar-path))
#+END_SRC

** Org-bullets

use [[https://github.com/sabof/org-bullets][org-bullets]] package to show utf-8 charactes

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org-bullets
    :ensure t
    :init
    (add-hook 'org-mode-hook
              (lambda ()
                (org-bullets-mode t))))

  (setq org-bullets-bullet-list '("⦿" "✪" "◉" "○" "►" "◆"))

  ;; increase font size when enter org-src-mode
  (add-hook 'org-src-mode-hook (lambda () (text-scale-increase 2)))
#+END_SRC

** Worf Mode

[[https://github.com/abo-abo/worf][worf]] mode is an extension of vi-like binding for org-mode. 
In =worf-mode=, it is mapping =[=, =]= as =worf-backward= and =worf-forward= in global, wich
cause we cannot input =[= and =]=, so here I unset this mappings. And redifined this two to
=M-[= and =M-]=. see this [[https://github.com/abo-abo/worf/issues/19#issuecomment-223756599][issue]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package worf
    :ensure t
    :commands worf-mode
    :init (add-hook 'org-mode-hook 'worf-mode)
    ;; :config
    ;; (define-key worf-mode-map "[" nil)
    ;; (define-key worf-mode-map "]" nil)
    ;; (define-key worf-mode-map (kbd "M-[") 'worf-backward)
    ;; (define-key worf-mode-map (kbd "M-]") 'worf-forward)
    )

#+END_SRC

** Get Things Done

Refer to [[http://doc.norang.ca/org-mode.html][Organize Your Life in Plain Text]]
*** basic setup

standard key binding

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Plain List 

Replace the list bullet =-=, =+=,  with =•=, a litter change based [[https://github.com/howardabrams/dot-files/blob/master/emacs-org.org][here]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (use-package org-mode
  ;;   :init
  ;;   (font-lock-add-keywords 'org-mode
  ;;    '(("^ *\\([-+]\\) "
  ;;           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•")))))))
#+END_SRC
 
*** Todo Keywords

refer to [[http://coldnew.github.io/coldnew-emacs/#orgheadline94][fancy todo states]], 

To track TODO state changes, the =!= is to insert a timetamp, =@= is to insert a note with
timestamp for the state change.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
    ;; (setq org-todo-keywords
    ;;        '((sequence "☛ TODO(t)" "|" "✔ DONE(d)")
    ;;          (sequence "⚑ WAITING(w)" "|")
    ;;          (sequence "|" "✘ CANCELLED(c)")))
  ; (setq org-todo-keyword-faces
  ;        (quote ("TODO" .  (:foreground "red" :weight bold))
  ;               ("NEXT" .  (:foreground "blue" :weight bold))
  ;               ("WAITING" . (:foreground "forest green" :weight bold))
  ;               ("DONE" .  (:foreground "magenta" :weight bold))
  ;               ("CANCELLED" . (:foreground "forest green" :weight bold))))


  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
                ;; (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" ))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ;; ("MEETING" :foreground "forest green" :weight bold)
                ;; ("PHONE" :foreground "forest green" :weight bold)
                )))
#+END_SRC

Fast todo selections

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

TODO state triggers and tags, [[http://doc.norang.ca/org-mode.html][Organize Your Life in Plain Text]]

- Moving a task to =CANCELLED=, adds a =CANCELLED= tag
- Moving a task to =WAITING=, adds a =WAITING= tag
- Moving a task to =HOLD=, add =HOLD= tags
- Moving a task to =DONE=, remove =WAITING=, =HOLD= tag
- Moving a task to =NEXT=, remove all waiting/hold/cancelled tags

This tags are used to filter tasks in agenda views
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+END_SRC

Logging Stuff 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; log time when task done
  ;; (setq org-log-done (quote time))
  ;; save clocking into to LOGBOOK
  (setq org-clock-into-drawer t)
  ;; save state change notes and time stamp into LOGBOOK drawer
  (setq org-log-into-drawer t)
  (setq org-clock-into-drawer "CLOCK")
#+END_SRC

*** Tags
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-tag-alist (quote ((:startgroup)
                              ("@office" . ?e)
                              ("@home" . ?h)
                              (:endgroup)
                              ("WAITING" . ?w)
                              ("HOLD" . ?h)
                              ("CANCELLED" . ?c))))

  ;; Allow setting single tags without the menu
  (setq org-fast-tag-selection-single-key (quote expert))
#+END_SRC

*** Capture - Refile - Archive

Capture lets you quickly store notes with little interruption of your work flow.

**** Capture Templates

When a new taks needs to be added, categorize it as 

All captured file which need next actions are stored in =refile.org=, 
- A new task / note (t) =refile.org=
- A work task in office =office.org=
- A jourenl =diary.org=
- A new habit (h) =refile.org=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-directory "~/org")
  (setq org-default-notes-file "~/org/refile.org")
  (setq sd/org-diary-file "~/org/diary.org")

  (global-set-key (kbd "C-c c") 'org-capture)

  (setq org-capture-templates
        (quote (("t" "Todo" entry (file org-default-notes-file)
                 "* TODO %?\n:LOGBOOK:\n- Added: %U\t\tAt: %a\n:END:")
                ("n" "Note" entry (file org-default-notes-file)
                 "* %? :NOTE:\n:LOGBOOK:\n- Added: %U\t\tAt: %a\n:END:")
                ("j" "Journal" entry (file+datetree sd/org-diary-file)
                 "* %?\n:LOGBOOK:\n:END:" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file org-default-notes-file)
                 "* NEXT %?\n:LOGBOOK:\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:END:\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n "))))
#+END_SRC

**** Refiling Tasks

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-refile-targets (quote (;; (nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))

  (setq org-refile-use-outline-path t)

  (setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC

*** Agenda Setup
Setting agenda files and the agenda view
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-agenda-files (quote ("~/org/gtd.org"
                                 "~/org/work.org")))

  ;; only show today's tasks in agenda view
  (setq org-agenda-span 'day)
  ;; Use current windows for agenda view
  (setq org-agenda-window-setup 'current-window)

  ;; show all feature entries for repeating tasks,
  ;; this is already setting by default
  (setq org-agenda-repeating-timestamp-show-all t)

  ;; Show all agenda dates - even if they are empty
  (setq org-agenda-show-all-dates t)
#+END_SRC

** Export PDF

Install MacTex-basic and some tex packages

#+BEGIN_SRC bash 

  sudo tlmgr update --self

  sudo tlmgr install titlesec framed threeparttable wrapfig multirow enumitem bbding titling tabu mdframed tcolorbox textpos import varwidth needspace tocloft ntheorem environ trimspaces collection-fontsrecommended capt-of

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; ;; allow for export=>beamer by placing

  ;; http://emacs-fu.blogspot.com/2011/04/nice-looking-pdfs-with-org-mode-and.html
  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n          
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")
 
       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"
 
       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


  (require 'ox-md)
  (require 'ox-beamer)

  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

  (setq TeX-parse-self t)

  (setq TeX-PDF-mode t)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))

#+END_SRC

** others

extend org-mode's easy templates, refer to [[http://coldnew.github.io/coldnew-emacs/#orgheadline94][Extend org-modes' esay templates]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp :tangle yes :results silent\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("p" "#+BEGIN_SRC plantuml :file uml.png \n?\n#+END_SRC"))

#+END_SRC

* Magit
[[https://github.com/magit/magit][Magit]] is a very cool git interface on Emacs.
and Defined keys, using vi keybindings, Refer abo-abo's setting [[https://github.com/abo-abo/oremacs/blob/c5cafdcebc88afe9e73cc8bd40c49b70675509c7/modes/ora-nextmagit.el][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package magit
    :ensure t
    :init
    ;; don't ask me to confirm the unsaved change 
    (setq magit-save-repository-buffers nil)
    :commands magit-status magit-blame
    :config
    (dolist (map (list magit-status-mode-map
                       magit-log-mode-map
                       magit-diff-mode-map
                       magit-staged-section-map))
      (define-key map "j" 'magit-section-forward)
      (define-key map "k" 'magit-section-backward)
      (define-key map "D" 'magit-discard)
      (define-key map "O" 'magit-discard-file)
      (define-key map "n" nil)
      (define-key map "p" nil)
      (define-key map "v" 'recenter-top-bottom)
      (define-key map "i" 'magit-section-toggle)))
#+END_SRC

* Eshell
*** Eshell alias
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defalias 'e 'find-file)
  (defalias 'ff 'find-file)
  (defalias 'ee 'find-files)
#+END_SRC

*** eshell temp directory
set default eshell history folder
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq eshell-directory-name (concat  sd-temp-directory "eshell"))
#+END_SRC

*** Eshell erase buffer
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/eshell-clear-buffer ()
    "Clear eshell buffer"
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))

   (add-hook 'eshell-mode-hook (lambda ()
                                (local-set-key (kbd "C-l") 'sd/eshell-clear-buffer)))
#+END_SRC

*** Toggle Eshell
Toggle an eshell in split window below, refer [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell-here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/window-has-eshell ()
    "Check if current windows list has a eshell buffer, and return the window"
    (interactive)
    (let ((ret nil))
      (walk-windows (lambda (window)
                      (if (equal (with-current-buffer (window-buffer window) major-mode)
                                 'eshell-mode)
                          (setq ret window)))
                    nil nil)
      ret))

  (defun sd/toggle-eshell-here ()
    "Toggle a eshell buffer vertically"
    (interactive)
    (if (sd/window-has-eshell)
        (if (equal major-mode 'eshell-mode)
            (progn
              (if (equal (length (window-list)) 1)
                  (mode-line-other-buffer)
                (delete-window)))
          (select-window (sd/window-has-eshell)))
      (progn
        (let ((dir default-directory))
        
          (split-window-vertically (- (/ (window-total-height) 3)))
          (other-window 1)
          (unless (and (boundp 'eshell-buffer-name) (get-buffer eshell-buffer-name))
            (eshell))
          (switch-to-buffer eshell-buffer-name)
          (goto-char (point-max))
          (eshell-kill-input)
          (insert (format "cd %s" dir))
          (eshell-send-input)))))

  ;; (global-unset-key (kbd "M-`"))
  (global-set-key (kbd "s-e") 'sd/toggle-eshell-here)
#+END_SRC

*** TODO smart display
* Misc Settings

** [[https://github.com/abo-abo/hydra][Hydra]]
*** hydra install
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package hydra
    :ensure t)
  ;; disable new line in minibuffer when hint hydra
  (setq hydra-lv nil)
#+END_SRC

*** Font Zoom
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defhydra sd/font-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out"))
#+END_SRC

*** Windmove Splitter

Refer [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-example]], to enlarge or shrink the windows splitter

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun hydra-move-splitter-left (arg)
    "Move window splitter left."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (shrink-window-horizontally arg)
      (enlarge-window-horizontally arg)))

  (defun hydra-move-splitter-right (arg)
    "Move window splitter right."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (enlarge-window-horizontally arg)
      (shrink-window-horizontally arg)))

  (defun hydra-move-splitter-up (arg)
    "Move window splitter up."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (enlarge-window arg)
      (shrink-window arg)))

  (defun hydra-move-splitter-down (arg)
    "Move window splitter down."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (shrink-window arg)
      (enlarge-window arg)))

#+END_SRC

*** hydra misc
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defhydra sd/hydra-misc (:color red :columns nil)
    "Miscellaneous Commands"
    ("e" eshell "eshell" :exit t)
    ("p" (lambda ()
           (interactive)
           (if (not (eq nil (get-buffer "*Packages*")))
               (switch-to-buffer "*Packages*")
             (package-list-packages)))
     "list-package" :exit t)
    ("g" magit-status "git-status" :exit t)
    ("'" mode-line-other-buffer "last buffer" :exit t)
    ("C-'" mode-line-other-buffer "last buffer" :exit t)
    ("m" man "man" :exit t)
    ("d" dired-jump "dired" :exit t)
    ("b" ibuffer "ibuffer" :exit t)
    ("q" nil "quit")
    ("f" nil "quit"))

  (global-set-key (kbd "C-'") 'sd/hydra-misc/body)
#+END_SRC

*** hydra launcher
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defhydra sd/hydra-launcher (:color blue :columns 2)
    "Launch"
    ("e" emms "emms" :exit t)
    ("q" nil "cancel"))
#+END_SRC

** Line Number

Enable linum mode on programming modes

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (add-hook 'prog-mode-hook 'linum-mode)
  ;; (add-hook 'prog-mode-hook (lambda ()
  ;;                             (setq-default indicate-empty-lines t)))
#+END_SRC

Fix the font size of line number

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun fix-linum-size ()
       (interactive)
       (set-face-attribute 'linum nil :height 110))

  (add-hook 'linum-mode-hook 'fix-linum-size)

#+END_SRC

I like [[https://github.com/coldnew/linum-relative][linum-relative]], just like the =set relativenumber= on =vim=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package linum-relative
    :ensure t
    :config
    (defun linum-new-mode ()
      "If line numbers aren't displayed, then display them.
  Otherwise, toggle between absolute and relative numbers."
      (interactive)
      (if linum-mode
          (linum-relative-toggle)
        (linum-mode 1)))

    :bind
    ("A-k" . linum-new-mode))

  ;; auto enable linum-new-mode in programming modes
  (add-hook 'prog-mode-hook 'linum-relative-mode)

#+END_SRC

** Save File Position

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-forget-unreadable-files t)
  (setq save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)")

#+END_SRC

** Multi-term

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package multi-term
    :ensure t)

#+END_SRC

** ace-link

[[https://github.com/abo-abo/ace-link][ace-link]] is a package written by [[https://github.com/abo-abo][Oleh Krehel]]. It is convenient to jump to link in help mode, info-mode, etc
Type =o= to go to the link

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package ace-link
    :ensure t
    :init
    (ace-link-setup-default))

#+END_SRC

** Emux

[[https://github.com/re5et/emux][emux]] is 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (el-get-bundle re5et/emux)

#+END_SRC

** Smart Parens

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package smartparens
    :ensure t
    :config
    (progn
      (require 'smartparens-config)
      (add-hook 'prog-mode-hook 'smartparens-mode)))

#+END_SRC

** Ace-Windows

[[https://github.com/abo-abo/ace-window][ace-window]] 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package ace-window
    :ensure t
    :defer t
  ;  :init
  ;  (global-set-key (kbd "M-o") 'ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l)))

#+END_SRC

** Which key

[[https://github.com/justbur/emacs-which-key][which-key]] show the key bindings 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package which-key
    :ensure t
    :config
    (which-key-mode))

#+END_SRC

** Emms

We can use [[https://www.gnu.org/software/emms/quickstart.html][Emms]] for multimedia in Emacs

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package emms
    :ensure t
    :init
    (setq emms-source-file-default-directory "~/Music/")
    :config
    (emms-standard)
    (emms-default-players)
    (define-emms-simple-player mplayer '(file url)
      (regexp-opt '(".ogg" ".mp3" ".mgp" ".wav" ".wmv" ".wma" ".ape"
                    ".mov" ".avi" ".ogm" ".asf" ".mkv" ".divx" ".mpeg"
                    "http://" "mms://" ".rm" ".rmvb" ".mp4" ".flac" ".vob"
                    ".m4a" ".flv" ".ogv" ".pls"))
      "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen")
    (emms-history-load))

#+END_SRC

** GnoGo

Play Go in Emacs, gnugo xpm refert [[https://github.com/okanotor/dotemacs/blob/f95b774cb292d1169748bc0a62ba647bbd8c0652/etc/my-inits/my-inits-gnugo.el][to here]]. start at image display mode and grid mode

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package gnugo
    :ensure t
    :defer t
    :init
    (require 'gnugo-imgen)
    (setq gnugo-xpms 'gnugo-imgen-create-xpms)
    (add-hook 'gnugo-start-game-hook '(lambda ()
                                        (gnugo-image-display-mode)
                                        (gnugo-grid-mode)))
      :config
    (add-to-list 'gnugo-option-history (format "--boardsize 19 --color black --level 1")))

#+END_SRC

** Tabbar

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  ;; (use-package tabbar-ruler
  ;;   :ensure t
  ;;   :init
  ;;   (setq tabbar-ruler-global-tabbar t)
  ;;   (setq tabbar-ruler-global-ruler t)
  ;;   (setq tabbar-ruler-popu-menu t)
  ;;   (setq tabbar-ruler-popu-toolbar t)
  ;;   (setq tabbar-use-images t)
  ;;   :config
  ;;   (tabbar-ruler-group-by-projectile-project)
  ;;   (global-set-key (kbd "s-1") 'tabbar-forward-group)
  ;;   (global-set-key (kbd "s-2") 'tabbar-ruler-forward))

#+END_SRC

** View only for some directory
When see function by =C-h f=, and visit the source code, I would like the buffer is read only. See [[http://emacs.stackexchange.com/questions/3676/how-to-enter-view-only-mode-when-browsing-emacs-source-code-from-help/3681#3681][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (dir-locals-set-class-variables
   'emacs
   '((nil . ((buffer-read-only . t)
             (show-trailing-whitespace . nil)
             (tab-width . 8)
             (eval . (whitespace-mode -1))))))

  ;; (dir-locals-set-directory-class (expand-file-name "/usr/local/share/emacs") 'emacs)
  (dir-locals-set-directory-class "/usr/local/Cellar/emacs" 'emacs)
  ;; (dir-locals-set-directory-class "~/.emacs.d/elpa" 'emacs)
  (dir-locals-set-directory-class "~/dotfiles/emacs.d/elpa" 'emacs)
  (dir-locals-set-directory-class "~/dotfiles/emacs.d/el-get" 'emacs)
#+END_SRC

** Info plus
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (el-get-bundle info+
    :url "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/info+.el"
    (require 'info+))
#+END_SRC

** TODO bookmark

** TODO Calendar
** advice info
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/info-mode ()
    (interactive)
    (unless (equal major-mode 'Info-mode)
      (unless (> (length (window-list)) 1)
        (split-window-right))
      (other-window 1)
      ;; (info)
      ))

  ;; (global-set-key (kbd "C-h i") 'sd/info-mode)

  ;; open Info buffer in other window instead of current window
  (defadvice info (before my-info (&optional file buf) activate)
    (sd/info-mode))

  (defadvice Info-exit (after my-info-exit activate)
    (sd/delete-current-window))
#+END_SRC

** TODO Man mode
Color for Man-mode

** TODO swiper to occur

** TODO UTF8
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (set-language-environment "UTF-8")
  ;; (set-default-coding-systems 'utf-8)
#+END_SRC

** Demo It
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (el-get-bundle howardabrams/demo-it)

  (use-package org-tree-slide
    :ensure t)

  ;; (use-package yasnippet
  ;;   :ensure t)
#+END_SRC

** Presentation
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org-tree-slide
    :ensure
    :config
    ;; (define-key org-mode-map "\C-ccp" 'org-tree-slide-mode)
    (define-key org-tree-slide-mode-map (kbd "<ESC>") 'org-tree-slide-content)
    (define-key org-tree-slide-mode-map (kbd "<SPACE>") 'org-tree-slide-move-next-tree)
    (define-key org-tree-slide-mode-map [escape] 'org-tree-slide-move-previous-tree))
#+END_SRC

* dired
=C-o= is defined as a global key for window operation, here unset it in dired mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package dired
    :config
    (require 'dired-x)
    (setq dired-omit-mode t)
    (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
    (add-hook 'dired-mode-hook (lambda ()
                                 (define-key dired-mode-map (kbd "C-o") nil)
                                 (define-key dired-mode-map (kbd "H") 'dired-omit-mode)
                                 (define-key dired-mode-map (kbd "DEL") (lambda () (interactive) (find-alternate-file "..")))
                                 (dired-omit-mode))))
#+END_SRC

Dired+
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package dired+
    :ensure t
    :init
    (setq diredp-hide-details-initially-flag nil)
    :config
    (define-key dired-mode-map (kbd "j") 'diredp-next-line)
    (define-key dired-mode-map (kbd "k") 'diredp-previous-line)
    (define-key dired-mode-map (kbd "g") 'dired-goto-file))
#+END_SRC

* Completion
company mode and company-statistics
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package company
    :ensure t
    :diminish company-mode
    :init (setq company-idle-delay 0.1)
    :config
    (global-company-mode))

  (use-package company-statistics
    :ensure t
    :config
    (company-statistics-mode))
#+END_SRC

* Programming Language
** Emacs Lisp
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package color-identifiers-mode
    :ensure t
    :init
    (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)

    :diminish color-identifiers-mode)

  (global-prettify-symbols-mode t)
#+END_SRC

In Lisp Mode, =M-o= is defined, but I use this for global hydra window. So here disable this key
bindings in =lispy-mode-map= after loaded. see [[http://stackoverflow.com/questions/298048/how-to-handle-conflicting-keybindings][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package lispy
    :ensure t
    :init
    (eval-after-load "lispy"
      `(progn
         (define-key lispy-mode-map (kbd "M-o") nil)))
    :config
    (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1))))
#+END_SRC

** Perl
*** CPerl mode
[[https://www.emacswiki.org/emacs/CPerlMode][CPerl mode]] has more features than =PerlMode= for perl programming. Alias this to =CPerlMode=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defalias 'perl-mode 'cperl-mode)

  ;; (setq cperl-hairy t)
  ;; Turns on most of the CPerlMode options
  (setq cperl-auto-newline t)
  (setq cperl-highlight-variables-indiscriminately t)
  ;(setq cperl-indent-level 4)
  ;(setq cperl-continued-statement-offset 4)
  (setq cperl-close-paren-offset -4)
  (setq cperl-indent-parents-as-block t)
  (setq cperl-tab-always-indent t)
  ;(setq cperl-brace-offset  0)

  (add-hook 'cperl-mode-hook
            '(lambda ()
               (cperl-set-style "C++")))

  (defalias 'perldoc 'cperl-perldoc)
#+END_SRC

*** Perl template
Refer [[https://www.emacswiki.org/emacs/AutoInsertMode][AutoInsertMode]] Wiki
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.pl\\'" . "Perl skeleton")
       '(
         "Empty"
         "#!/usr/bin/perl -w" \n
         \n
         "use strict;" >  \n \n
         > _
         )))
#+END_SRC

*** Perl Keywords
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (font-lock-add-keywords 'cperl-mode
                          '(("\\(say\\)" . cperl-nonoverridable-face)
                            ("\\([0-9.]\\)*" . font-lock-constant-face)
                            ("\".*\\(\\\n\\).*\"" . font-lock-constant-face)
                            ("\n" . font-lock-constant-face)
                            ("\\(^#!.*\\)$" .  cperl-nonoverridable-face)))

    ;; (font-lock-add-keywords 'Man-mode
    ;;                         '(("\\(NAME\\)" . font-lock-function-name-face)))

#+END_SRC

*** Run Perl
Change the compile-command to set the default command run when call =compile=
Mapping =s-r= (on Mac, it's =Command + R= to run the script. Here =current-prefix-arg= is set
to call =compilation=  interactively.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun my-perl-hook ()
    (progn
      (setq-local compilation-read-command nil)
      (set (make-local-variable 'compile-command)
           (concat "/usr/bin/perl "
                   (if buffer-file-name
                       (shell-quote-argument buffer-file-name))))
      (local-set-key (kbd "s-r")
                     (lambda ()
                       (interactive)
                                          ;                       (setq current-prefix-arg '(4)) ; C-u
                       (call-interactively 'compile)))))

  (add-hook 'cperl-mode-hook 'my-perl-hook)
#+END_SRC

** C & C++
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq c-default-style "stroustrup"
        c-basic-offset 4)
#+END_SRC

* Compile
Set the environments vairables in compilation mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package compile
    :commands compile
    :config
    (setq compilation-environment (cons "LC_ALL=C" compilation-environment))
    (setq compilation-auto-jump-to-first-error t)
    (setq compilation-auto-jump-to-next t)
    (setq compilation-scroll-output 'first-error))

  ;; super-r to compile
  (with-eval-after-load "compile"
    (define-key compilation-mode-map (kbd "C-o") nil)
    (define-key compilation-mode-map (kbd "n") 'compilation-next-error)
    (define-key compilation-mode-map (kbd "p") 'compilation-previous-error)
    (define-key compilation-mode-map (kbd "r") #'recompile))
#+END_SRC

* Auto-Insert
** Enable auto-insert mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (auto-insert-mode t)
  (setq auto-insert-query nil)
#+END_SRC

** C++ Auto Insert
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.cpp\\'" . "C++ skeleton")
       '(
         "Short description:"
         "/*"
         "\n * " (file-name-nondirectory (buffer-file-name))
         "\n */" > \n \n
         "#include <iostream>" \n
         "#include \""
         (file-name-sans-extension
          (file-name-nondirectory (buffer-file-name)))
         ".hpp\"" \n \n
         "using namespace std;" \n \n
         "int main ()"
         "\n{" \n 
         > _ \n
         "return 1;"
         "\n}" > \n
         )))

  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.c\\'" . "C skeleton")
       '(
         "Short description:"
         "/*\n"
         " * " (file-name-nondirectory (buffer-file-name)) "\n"
         " */" > \n \n
         "#include <stdio.h>" \n
         "#include \""
         (file-name-sans-extension
          (file-name-nondirectory (buffer-file-name)))
         ".h\"" \n \n
         "int main ()\n"
         "{" \n
         > _ \n
         "return 1;\n"
         "}" > \n
         )))
#+END_SRC

** Python template
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.\\(py\\)\\'" . "Python skeleton")
       '(
         "Empty"
         "#import os,sys" \n
         \n \n
         )))
#+END_SRC

** Elisp 
Emacs lisp auto-insert, based on the default module in =autoinsert.el=, but replace =completing-read= as 
=completing-read-ido-ubiquitous= to fix the edge case of that =ido= cannot handle.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.el\\'" . "my Emacs Lisp header")
       '(
         "Short description: "
         ";;; " (file-name-nondirectory (buffer-file-name)) " --- " str
         (make-string (max 2 (- 80 (current-column) 27)) ?\s)
         "-*- lexical-binding: t; -*-" '(setq lexical-binding t)
         "\n
  ;; Copyright (C) " (format-time-string "%Y") "  "
         (getenv "ORGANIZATION") | (progn user-full-name) "

  ;; Author: " (user-full-name)
         '(if (search-backward "&" (line-beginning-position) t)
              (replace-match (capitalize (user-login-name)) t t))
         '(end-of-line 1) " <" (progn user-mail-address) ">
  ;; Keywords: "
         '(require 'finder)
         ;;'(setq v1 (apply 'vector (mapcar 'car finder-known-keywords)))
         '(setq v1 (mapcar (lambda (x) (list (symbol-name (car x))))
                           finder-known-keywords)
                v2 (mapconcat (lambda (x) (format "%12s:  %s" (car x) (cdr x)))
                              finder-known-keywords
                              "\n"))
         ((let ((minibuffer-help-form v2))
            (completing-read-ido-ubiquitous "Keyword, C-h: " v1 nil t))
          str ", ") & -2 "

  \;; This program is free software; you can redistribute it and/or modify
  \;; it under the terms of the GNU General Public License as published by
  \;; the Free Software Foundation, either version 3 of the License, or
  \;; (at your option) any later version.

  \;; This program is distributed in the hope that it will be useful,
  \;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  \;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  \;; GNU General Public License for more details.

  \;; You should have received a copy of the GNU General Public License
  \;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  \;;; Commentary:

  \;; " _ "

  \;;; Code:


  \(provide '"
         (file-name-base)
         ")
  \;;; " (file-name-nondirectory (buffer-file-name)) " ends here\n")))
#+END_SRC

** Org file template
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.\\(org\\)\\'" . "Org-mode skeleton")
       '(
         "title: "
         "#+TITLE: " str (make-string 30 ?\s) > \n
         "#+AUTHOR: Peng Li\n"
         "#+EMAIL: seudut@gmail.com\n"
         "#+DATE: " (shell-command-to-string "echo -n $(date +%Y-%m-%d)") > \n
         > \n
         > _)))
#+END_SRC

* Markdown mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package markdown-preview-eww
    :ensure t)
#+END_SRC

* Gnus
** Gmail setting 
Refer [[https://www.emacswiki.org/emacs/GnusGmail][GnusGmail]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq user-mail-address "seudut@gmail.com"
        user-full-name "Peng Li")

  (setq gnus-select-method
        '(nnimap "gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))

  (setq smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

  ;; Use gmail sending mail
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials '(("smtp.gmail.com" 587 "seudut@gmail.com" nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        starttls-use-gnutls t)
#+END_SRC

And put the following in =~/.authinfo= file, replacing =<USE>= with your email address
and =<PASSWORD>= with the password
#+BEGIN_EXAMPLE
  machine imap.gmail.com login <USER> password <PASSWORD> port imaps
  machine smtp.gmail.com login <USER> password <PASSWORD> port 587
#+END_EXAMPLE

Then Run =M-x gnus=

** Group buffer
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package gnus
    :init
    (setq gnus-permanently-visible-groups "\.*")
    :config
    (cond (window-system
           (setq custom-background-mode 'light)
           (defface my-group-face-1
             '((t (:foreground "Red" :bold t))) "First group face")
           (defface my-group-face-2
             '((t (:foreground "DarkSeaGreen4" :bold t)))
             "Second group face")
           (defface my-group-face-3
             '((t (:foreground "Green4" :bold t))) "Third group face")
           (defface my-group-face-4
             '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
           (defface my-group-face-5
             '((t (:foreground "Blue" :bold t))) "Fifth group face")))
    (setq gnus-group-highlight
          '(((> unread 200) . my-group-face-1)
            ((and (< level 3) (zerop unread)) . my-group-face-2)
            ((< level 3) . my-group-face-3)
            ((zerop unread) . my-group-face-4)
            (t . my-group-face-5))))


  ;; key-
  (add-hook 'gnus-group-mode-hook (lambda ()
                                    (define-key gnus-group-mode-map "k" 'gnus-group-prev-group)
                                    (define-key gnus-group-mode-map "j" 'gnus-group-next-group)
                                    (define-key gnus-group-mode-map "g" 'gnus-group-jump-to-group)
                                    (define-key gnus-group-mode-map "v" (lambda () (interactive) (gnus-group-select-group t)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq gnus-fetch-old-headers 't)



  (setq gnus-extract-address-components
        'mail-extract-address-components)
  ;; summary buffer 
  (setq gnus-summary-line-format "%U%R%z%I%(%[%-20,20f%]%)  %s%-80=   %11&user-date;\n")
  (setq gnus-user-date-format-alist '(((gnus-seconds-today) . "%H:%M")
                                      ((+ 86400 (gnus-seconds-today)) . "%a %H:%M")
                                      (604800 . "%a, %b %-d")
                                      (15778476 . "%b %-d")
                                      (t . "%Y-%m-%d")))

  (setq gnus-thread-sort-functions '((not gnus-thread-sort-by-number)))
  (setq gnus-unread-mark ?\.)
  (setq gnus-use-correct-string-widths t)

  ;; thread
  (setq gnus-thread-hide-subtree t)

  ;; (with-eval-after-load 'gnus-summary-mode
  ;;   (define-key gnus-summary-mode-map (kbd "C-o") 'sd/hydra-window/body))

  (add-hook 'gnus-summary-mode-hook (lambda ()
                                      (define-key gnus-summary-mode-map (kbd "C-o") nil)))


#+END_SRC

** Windows layout
See [[https://www.emacswiki.org/emacs/GnusWindowLayout][GnusWindowLayout]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (gnus-add-configuration
   '(summary
     (horizontal 1.0
                 (vertical 35
                           (group 1.0))
                 (vertical 1.0
                           (summary 1.0 poine)))))

  (gnus-add-configuration
   '(article
     (horizontal 1.0
                 (vertical 35
                           (group 1.0))
                 (vertical 1.0
                           (summary 0.50 point)
                           (article 1.0)))))

  (with-eval-after-load 'gnus-group-mode
    (gnus-group-select-group "INBOX"))
  ;; (add-hook 'gnus-group-mode-map (lambda ()
  ;;                               (gnus-group-select-group "INBOX")))
#+END_SRC

* Gnu Plot
To fix some issue that =toolbar-make-button-list= is void, see the [[https://github.com/bruceravel/gnuplot-mode/issues/31][issue]], here I set some variable as =nil=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package gnuplot
    :ensure
    :init
    (setq gnuplot-help-xpm nil)
    (setq gnuplot-line-xpm nil)
    (setq gnuplot-region-xpm nil)
    (setq gnuplot-buffer-xpm nil)
    (setq gnuplot-doc-xpm nil))
#+END_SRC

Use =gnuplot= on =Org-mode= file, see [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][ob-doc-gnuplot]]
#+BEGIN_SRC gnuplot :exports code :file ./temp/file.png
  reset

  set title "Putting it All Together"

  set xlabel "X"
  set xrange [-8:8]
  set xtics -8,2,8


  set ylabel "Y"
  set yrange [-20:70]
  set ytics -20,10,70

  f(x) = x**2
  g(x) = x**3
  h(x) = 10*sqrt(abs(x))

  plot f(x) w lp lw 1, g(x) w p lw 2, h(x) w l lw 3
#+END_SRC

#+RESULTS:
[[file:./temp/file.png]]

* Blog
#+BEGIN_SRC emacs-lisp :tangle yes :results silent

#+END_SRC

* key
- passion
- vision
- mission
* Ediff
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (with-eval-after-load 'ediff
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (add-hook 'ediff-startup-hook 'ediff-toggle-wide-display)
    (add-hook 'ediff-cleanup-hook 'ediff-toggle-wide-display)
    (add-hook 'ediff-suspend-hook 'ediff-toggle-wide-display))
#+END_SRC

* TODO Convert ASCII to key
** map =function-key-map= [[http://academic.evergreen.edu/projects/biophysics/technotes/program/ascii_ctrl.htm][ascii_ctrl]]
new file =C-x C-f C-f=

** write color syntax for =Man-mode=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (font-lock-add-keywords 'perl-mode '(("\\(|\\w+?\\(,\\w+?\\)?|\\)" 1 'py-builtins-face)))
#+END_SRC

* TODO set fly-spell binding

* TODO imenu bindings

* DONE modified indicator
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-07-18 Mon 23:35]
:END:
* DONE highlight selected ido candicate
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-07-19 Tue 01:49]
:END:
* DONE show time in right of mode-line
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-07-19 Tue 01:11]
:END:
* DONE ediff mode
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-07-19 Tue 01:11]
:END:
* TODO jump last change point
* TODO emms mode-line

* NEXT Key Bindings
Here are some global key bindings for basic editting
** Project operations - =super=
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package projectile
    :ensure t
    :init
    (setq projectile-enable-caching t)
    :config
    (projectile-global-mode t))

  (use-package persp-projectile
    :ensure t
    :config
    (persp-mode)
    :bind
    (:map projectile-mode-map
          ("s-t" . projectile-persp-switch-project)))

  ;; projectile-find-file
  ;; projectile-switch-buffer
  ;; projectile-find-file-other-window
#+END_SRC

*** project config =super= keybindings
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (global-set-key (kbd "s-h") 'keyboard-quit)
  ;; (global-set-key (kbd "s-j") 'ido-switch-buffer)
  ;; (global-set-key (kbd "s-k") 'ido-find-file)
  ;; (global-set-key (kbd "s-l") 'sd/delete-current-window)
  ;; s-l  -->  goto-line
  ;; (global-set-key (kbd "s-/") 'swiper)
  ;; s-;  -->
  ;; s-'  -->  'next-multiframe-window
  (global-set-key (kbd "<s-return>") 'toggle-frame-fullscreen)

  (global-set-key (kbd "s-f") 'projectile-find-file)
  (global-set-key (kbd "s-`") 'mode-line-other-buffer)

  (global-set-key (kbd "s-n") 'persp-next)
  (global-set-key (kbd "s-p") 'persp-prev)

  (global-set-key (kbd "s-=") 'text-scale-increase)
  (global-set-key (kbd "s--") 'text-scale-decrease)

  ;; (global-set-key (kbd "s-u") 'undo-tree-visualize)


  ;; someothers default mapping on super (command) key
  ;; s-s save-buffer
  ;; s-k kill-this-buffer


  ;; s-h  -->  ns-do-hide-emacs
  ;; s-j  -->  ido-switch-buffer  +
  ;; s-k  -->  kill-this-buffer
  ;; s-l  -->  goto-line
  ;; s-;  -->  undefined
  ;; s-'  -->  next-multiframe-window
  ;; s-ret --> toggle-frame-fullscreen +

  ;; s-y  -->  ns-paste-secondary
  ;; s-u  -->  revert-buffer
  ;; s-i  -->  undefined - but used for iterm globally
  ;; s-o  -->  used for emacs globally
  ;; s-p  -->  projectile-persp-switch-project  +  
  ;; s-[  -->  next-buffer  +    
  ;; s-]  -->  previous-buffer +

  ;; s-0  -->  undefined
  ;; s-9  -->  undefined
  ;; s-8  -->  undefined
  ;; s-7  -->  undefined
  ;; s-6  -->  undefined
  ;; s--  -->  center-line
  ;; s-=  -->  undefined

  ;; s-n  -->  make-frame
  ;; s-m  -->  iconify-frame
  ;; s-b  -->  undefined
  ;; s-,  -->  customize
  ;; s-.  -->  undefined
  ;; s-/  -->  undefined

  ;; s-g  -->  isearch-repeat-forward
  ;; s-f  -->  projectile-find-file   +
  ;; s-d  -->  isearch-repeat-background
  ;; s-s  -->  save-buffer
  ;; s-a  -->  make-whole-buffer

  ;; s-b  -->  undefined
  ;; s-v  -->  yank
  ;; s-c  -->  ns-copy-including-secondary

  ;; s-t  -->  ns-popup-font-panel
  ;; s-r  -->  undefined
  ;; s-e  -->  isearch-yanqk-kill
  ;; s-w  -->  delete-frame
  ;; s-q  -->  same-buffers-kill-emacs

  ;; s-`  -->  other-frame
#+END_SRC

** Windown & Buffer - =C-o=
Defind a =hydra= function for windows, buffer & bookmark operations. And map it to =C-o= globally.
Most use =C-o C-o= to switch buffers; =C-o x, v= to split window; =C-o o= to delete other windows
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (winner-mode 1)

  (defun sd/delete-current-window ()
    (interactive)
    (if (> (length (window-list)) 1)
        (delete-window)
      (message "Only one Windows now!")))

  (defun sd/toggle-max-windows ()
    "Set maximize current if there are multiple windows, if only
  one window, window undo"
    (interactive)
    (if (equal  (length (window-list)) 1)
        (winner-undo)
      (delete-other-windows)))

  (defhydra sd/hydra-window (:color red :columns nil)
    "window"
    ("h" windmove-left nil :exit t)
    ("j" windmove-down nil :exit t)
    ("k" windmove-up nil :exit t)
    ("l" windmove-right nil :exit t)
    ("H" hydra-move-splitter-left nil)
    ("J" hydra-move-splitter-down nil)
    ("K" hydra-move-splitter-up nil)
    ("L" hydra-move-splitter-right nil)
    ("v" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right))
     "vert" :exit t)
    ("x" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down))
     "horz" :exit t)
    ;; ("o" delete-other-windows "one" :exit t)
    ("o" sd/toggle-max-windows "one" :exit t)
    ("C-o" ido-switch-buffer "buf" :exit t)
    ("C-k" sd/delete-current-window "del" :exit t)
    ("'" other-window "other" :exit t)
    ("a" ace-window "ace")
    ("s" ace-swap-window "swap")
    ("d" ace-delete-window "ace-one" :exit t)
    ("i" ace-maximize-window "ace-one" :exit t)
    ("b" ido-switch-buffer "buf" :exit t)
    ("C-b" ido-switch-buffer "buf" :exit t)
    ("m" bookmark-jump-other-window "open bmk" :exit t)
    ("M" bookmark-set "set bmk" :exit t)
    ("q" nil "cancel")
    ("u" (progn (winner-undo) (setq this-command 'winner-undo)) "undo")
    ("r" (progn (winner-redo) (setq this-command 'winner-redo)) "redo")
    ("C-h" nil nil :exit t)
    ("C-j" nil nil :exit t)
    ;; ("C-k" nil :exit t)
    ("C-l" nil nil :exit t)
    ("C-;" nil nil :exit t)
    ("p" nil nil :exit t)
    ("n" nil nil :exit t)
    ("[" nil nil :exit t)
    ("]" nil nil :exit t)
    ("f" nil))

  (global-unset-key (kbd "C-o"))
  (global-set-key (kbd "C-o") 'sd/hydra-window/body)
#+END_SRC

** Motion
- =C-M-=
[[https://www.masteringemacs.org/article/effective-editing-movement][effective-editing-movement]]
*** Command Arguments, numeric argumens
=C-u 4= same as =C-4=, =M-4=
*** Basic movement
moving by line / word / 
=C-f=, =C-b=, =C-p=, =C-n=, =M-f=, =M-b=
=C-a=, =C-e=
=M-m= (move first non-whitespace on this line) 
=M-}=, =M-{=, Move forward end of paragraph
=M-a=, =M-e=,  beginning / end of sentence
=C-M-a=, =C-M-e=, move begining of defun
=C-x ]=, =C-x [=, forward/backward one page
=C-v=, =M-v=, =C-M-v=, =C-M-S-v= scroll down/up
=M-<=, =M->=, beginning/end of buffer
=M-r=, Repositiong point

*** Moving by S-expression / List
*** Marks
=C-<SPC>= set marks toggle the region
=C-u C-<SPC>= Jump to the mark, repeated calls go further back the mark ring
=C-x C-x= Exchanges the point and mark.

Stolen [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][fixing-mark-commands-transient-mark-mode]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun push-mark-no-activate ()
    "Pushes `point' to `mark-ring' and does not activate the region
     Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  ;; (global-set-key (kbd "C-`") 'push-mark-no-activate)

  (defun jump-to-mark ()
    "Jumps to the local mark, respecting the `mark-ring' order.
    This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  ;; (global-set-key (kbd "M-`") 'jump-to-mark)

  (defun exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))

  ;; (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

Show the mark ring using =helm-mark-ring=, also mapping =M-`= to quit minibuffer. so that =M-`= can 
toggle the mark ring. the best way is add a new action and mapping to =helm-source-mark-ring=,  but 
since there is no map such as =helm-mark-ring=map=, so I cannot binding a key to the quit action.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "M-`") #'helm-mark-ring)

  (define-key minibuffer-local-map (kbd "M-`") 'keyboard-escape-quit)
#+END_SRC

=M-h= marks the next paragraph
=C-x h= marks the whole buffer
=C-M-h= marks the next defun
=C-x C-p= marks the next page
**** DONE Mapping toggle mark ring=
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-07-22 Fri 23:18]
:END:
*** Registers
Registers can save text, position, rectangles, file and configuration and other things.
Here for movement, we can use register to save/jump position
=C-x r SPC= store point in register
=C-x r j= jump to register
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package list-register
    :ensure t)
#+END_SRC

*** Bookmarks
As I would like use bookmakr for different buffer/files. to help to swith
different buffer/file quickly. this setting is in Windows/buffer node
=C-x r m= set a bookmarks
=C-x r l= list bookmarks
=C-x r b= jump to bookmarks

*** Search
Search, replace and hightlight will in later paragraph
*** =Avy= for easy motion
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package avy
    :ensure t
    :config
    (avy-setup-default))

  (global-set-key (kbd "C-M-j") 'avy-goto-line-below)
  (global-set-key (kbd "C-M-n") 'avy-goto-line-below)
  (global-set-key (kbd "C-M-k") 'avy-goto-line-above)
  (global-set-key (kbd "C-M-p") 'avy-goto-line-above)

  (global-set-key (kbd "C-M-f") 'avy-goto-word-1-below)
  (global-set-key (kbd "C-M-b") 'avy-goto-word-1-above)

  ;; (global-set-key (kbd "M-g e") 'avy-goto-word-0)
  (global-set-key (kbd "C-M-w") 'avy-goto-char-timer)
  (global-set-key (kbd "C-M-l") 'avy-goto-char-in-line)

  ;; ;; will delete above 
  ;; (global-set-key (kbd "M-g j") 'avy-goto-line-below)
  ;; (global-set-key (kbd "M-g k") 'avy-goto-line-above)
  ;; (global-set-key (kbd "M-g w") 'avy-goto-word-1-below)
  ;; (global-set-key (kbd "M-g b") 'avy-goto-word-1-above)
  ;; (global-set-key (kbd "M-g e") 'avy-goto-word-0)
  ;; (global-set-key (kbd "M-g f") 'avy-goto-char-timer)
  ;; (global-set-key (kbd "M-g c") 'avy-goto-char-in-line)
#+END_SRC

*** =Imenu= goto tag
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (global-set-key (kbd "M-i") #'counsel-imenu)
  (global-set-key (kbd "M-i") #'imenu)

  ;; (global-set-key (kbd "M-l") 'goto-line)
#+END_SRC

*** Go-to line
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "M-l") 'goto-line)
#+END_SRC

*** Movement effective
**** isearch
=C-s=, =C-r=
=C-w=, put the word into search minibuffer, =M-y=
=M-c=, toggle case sensitivity
=M-n=, =M-p=, history
**** tagss
** Edit
*** basic editting
- cut, yank, =C-w=, =C-y=
- save, revert
- undo, redo - undo-tree
- select, expand-region
- spell check, flyspell

*** Kill ring
=helm-show-kill-ring=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "M-y") #'helm-show-kill-ring)
#+END_SRC

** Search & Replace / hightlight =M-s=
*** search
*** replace
*** hightlight
#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  ;; (defhydra sd/search-highlight (:color red :columns nil)
  ;;   "search"
  ;;   ("M-s" . isearch-forward-regexp "search-forward" :exit t)
  ;;   ("s" . isearch-forward-regexp "search-forward" :exit t)
  ;;   ("r" . isearch-backward-regexp "search-backward" :exit t)
  ;;   )

  ;; (setq-default indicate-empty-lines t)
#+END_SRC

*** Occur
Occur search key bindings
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/occur-keys ()
    "My key bindings in occur-mode"
    (interactive)
    (switch-to-buffer-other-window "*Occur*")
    (define-key occur-mode-map (kbd "C-o") nil)
    (define-key occur-mode-map (kbd "C-n") (lambda ()
                                             (interactive)
                                             (occur-next)
                                             (occur-mode-goto-occurrence-other-window)
                                             (recenter)
                                             (other-window 1)))
    (define-key occur-mode-map (kbd "C-p") (lambda ()
                                             (interactive)
                                             (occur-prev)
                                             (occur-mode-goto-occurrence-other-window)
                                             (recenter)
                                             (other-window 1))))

  (add-hook 'occur-hook #'sd/occur-keys)

  (use-package color-moccur
    :ensure t
    :commands (isearch-moccur isearch-all)
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))
#+END_SRC

*** Swiper
stolen from [[https://github.com/mariolong/emacs.d/blob/f6a061594ef1b5d1f4750e9dad9dc97d6e122840/emacs-init.org][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package swiper
    :ensure t
    :init
    (setq ivy-use-virtual-buffers t)
    (set-face-attribute 'ivy-current-match nil :background "Orange" :foreground "black")
    :config
    (ivy-mode)
    (global-set-key (kbd "s-/") 'swiper)
    (define-key swiper-map (kbd "M-r") 'swiper-query-replace)
    (define-key swiper-map (kbd "C-.") (lambda ()
                                         (interactive)
                                         (insert (format "%s" (with-ivy-window (thing-at-point 'word))))))
    (define-key swiper-map (kbd "M-.") (lambda ()
                                         (interactive)
                                         (insert (format "%s" (with-ivy-window (thing-at-point 'symbol)))))))
#+END_SRC

* Dictionary
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package bing-dict
    :ensure t
    :init
    (global-set-key (kbd "s-d") 'bing-dict-brief)
    :commands (bing-dict-brief))
#+END_SRC

* TODO Temp directory for cached/history/temp files
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package recentf
    :config
    (setq recentf-save-file (concat sd-temp-directory "recentf")))

  (use-package projectile
    :config
    (setq projectile-cache-file (concat sd-temp-directory "projectile.cache")))

  (use-package ido
    :config
    (setq ido-save-directory-list-file (concat sd-temp-directory "ido.last")))

  (use-package savehist
    :config
    (setq savehist-file (concat sd-temp-directory "history")))

  (use-package emms
    :config
    (setq emms-directory (concat sd-temp-directory "emms")))

  (setq auto-save-list-file-prefix (concat sd-temp-directory "auto-save-list/.saves-")) 

  (use-package smex
    :config
    (setq smex-save-file (concat sd-temp-directory "smex-items")))
#+END_SRC

* test
#+BEGIN_SRC ditaa :file temp/hello-world.png :cmdline -r
+--------------+
|              |
| Hello World! |
|              |
+--------------+
#+END_SRC

#+RESULTS:
[[file:temp/hello-world.png]]

#+BEGIN_SRC ditaa :file temp/hello.png
  +------------+
  |            |
  |   hello    |       
  |            |
  +------------+      

 
#+END_SRC

#+RESULTS:
[[file:temp/hello.png]]

* =C-u C-h a= search funtions 
=apropos-command= 

* TODO Questions
- interactive for anonymous function
When define a key to a anonymous function, the lambda function should be interactive

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (require 'saveplace)
  ;; (setq-default save-place t)
  ;; (delete-selection-mode 1)
#+END_SRC


* M prefix
#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  ;; M-h - mark-paragraph
  ;; M-j - new line indent
  ;; M-k - kill-sentence
  ;; M-l - downcase words     ====== goto-line
  ;; M-; - comments
  ;; M-'- abbrev-prefix-mark  =======
  ;; M-RET none                ======

  ;; M-y - yank
  ;; M-u - upcase word
  ;; M-i -                 ====== imenu
  ;; M-o             ====== prefix
  ;; M-p
  ;; M-[                   =====
  ;; M-]              ========
  ;; M-\   deleter horizontal space =====

  ;; M-n 
  ;; M-m ---- indent
  ;; M-, --- mark stack====== =
  ;; M-. lisp-goto-symboo, find definitation

  ;; M-a 
  ;; M-s ===== 
  ;; M-d
  ;; M-f
  ;; M-g - prefix

  ;; M-q - lisp fill, fill paragraph
  ;; M-w 
  ;; M-e
  ;; M-r  - rePositioning 
  ;; M-t transpose word 

  ;; M-z zap-to-char
  ;; M-x
  ;; M-c  capitalize-word
  ;; M-v 
  ;; M-b 
#+END_SRC

