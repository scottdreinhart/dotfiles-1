#+TITLE: Study Note
#+AUTHOR: Peng Li
#+EMAIL: seudut@gmail.com
#+DATE: 2016-08-18

* Programming Languages
** Perl 
*** One line command
**** perl help
#+BEGIN_SRC sh :exports both :results output replace
  perl --help
#+END_SRC

#+RESULTS:
#+begin_example

Usage: perl [switches] [--] [programfile] [arguments]
  -0[octal]         specify record separator (\0, if no argument)
  -a                autosplit mode with -n or -p (splits $_ into @F)
  -C[number/list]   enables the listed Unicode features
  -c                check syntax only (runs BEGIN and CHECK blocks)
  -d[:debugger]     run program under debugger
  -D[number/list]   set debugging flags (argument is a bit mask or alphabets)
  -e program        one line of program (several -e's allowed, omit programfile)
  -E program        like -e, but enables all optional features
  -f                don't do $sitelib/sitecustomize.pl at startup
  -F/pattern/       split() pattern for -a switch (//'s are optional)
  -i[extension]     edit <> files in place (makes backup if extension supplied)
  -Idirectory       specify @INC/#include directory (several -I's allowed)
  -l[octal]         enable line ending processing, specifies line terminator
  -[mM][-]module    execute "use/no module..." before executing program
  -n                assume "while (<>) { ... }" loop around program
  -p                assume loop like -n but print line also, like sed
  -s                enable rudimentary parsing for switches after programfile
  -S                look for programfile using PATH environment variable
  -t                enable tainting warnings
  -T                enable tainting checks
  -u                dump core after parsing program
  -U                allow unsafe operations
  -v                print version, patchlevel and license
  -V[:variable]     print configuration summary (or a single Config.pm variable)
  -w                enable many useful warnings
  -W                enable all warnings
  -x[directory]     ignore text before #!perl line (optionally cd to directory)
  -X                disable all warnings
  
Run 'perldoc perl' for more help with Perl.

#+end_example

**** Used as =grep=
#+BEGIN_SRC sh
  perl -ne 'print if /expression/' xxx.log;
#+END_SRC

#+BEGIN_SRC perl :results output replace
  my $tt = "hello";
  ($tt =~ /h(.*)o/ ) and print $1;
#+END_SRC

#+RESULTS:
: ell

Or 
#+BEGIN_SRC sh
  perl -wnl -e '/keyword/ and print;' xxx.log
#+END_SRC

**** Used as =awk=
#+BEGIN_SRC sh
  perl -ne 'print "$1\n" if /aaa=(\d+)\s.*/' xxx.log;
#+END_SRC

#+BEGIN_SRC fundamental :tangle ./temp/aa.txt
  aa: 1
  bb: 2
  cc: 3
  dd: 4
#+END_SRC

#+BEGIN_SRC sh :results output replace
  perl -wnl -e 'print "==$.: $_"' ./temp/aa.txt
#+END_SRC

#+RESULTS:
: ==1: 
: ==2: aa: 1
: ==3: bb: 2
: ==4: cc: 3
: ==5: dd: 4

*** Special Variable
See special variable in perl [[http://perldoc.perl.org/perlvar.html][perlvar]], or =perldoc perlvar=
- =$.= Current line number

** gnuplog

1. normal
#+BEGIN_SRC gnuplot :exports code :file ./temp/sin.png
  reset
  plot sin(x)/x
#+END_SRC

#+RESULTS:
[[file:./temp/sin.png]]

2. plot with data file
#+BEGIN_SRC fundamental :tangle ./temp/plot.dat 
  # x y
  1 11
  2 12
  3 13
  4 14
  5 15
  6 16
  7 17
  8 18
  9 19
#+END_SRC

#+BEGIN_SRC gnuplot :file ./temp/ll.png
  reset
  set xrange [0:10]
  set yrange [0:20]
  plot "./temp/plot.dat" using 1:2 with lines
#+END_SRC

#+RESULTS:
[[file:./temp/ll.png]]

* TCP/IP
** netstat
#+BEGIN_SRC sh :results output replace
  netstat -atn    # For tcp port
  netstat -aun    # For udp port
  netstat -atun   # both
#+END_SRC

** nc (netcat)
#+BEGIN_SRC sh :results output replace
  # listening on port 1234 for a connection
  nc -l 1234

  # connect to the machine and port
  nc 127.0.0.1 1234
#+END_SRC

* Emacs
** =add-hook= vs =eval-after-load=
Ref [[http://stackoverflow.com/questions/2736087/eval-after-load-vs-mode-hook][eval-after-load-vs-mode-hook]]
#+BEGIN_QUOTE
Code wrapped in =eval-after-load= will be executed only once, so it is typically used to perform
one-time setup such as setting default global values and behaviour. An example might be setting
up a default keymap for a particular mode. In =eval-after-load= code, there's no notion of the 
"current buffer".

Mode hooks exectue once for every buffer in which the mode is enabled, so they're used for per-buffer
configuration. Mode hooks are therefore run later than =eval-after-load= code; this lets them take 
actions baed upon such information as whether other modes are enabled in the current buffer.
#+END_QUOTE

* ObjectiveC
** =#import= vs. =#include=
[[http://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c][what-is-the-difference-between-import-and-include-in-objective-c]]
- =#import= directive as added to Objective-C as an improvied version of =#include=
- =#import= ensures that a file is only ever included onces so that you never have a problem with recursive includes
- Bacically, use =#import= for Objective-C thins, =#include= for C stufff.


* Books
** Intruduction to Algorithms 
*** Foundations
**** The Role of Algorithms in Computing
** SICP (Structure and Interpretation of Computer Programs)
*** Building Abstractions with Procedures

The acts of the mind, wherein it exerts its power over simple ideas, are chiefly there threee: 1.
Combining serveral simple ideas into one compund one, and thus all complex ideas are made. 2. The
second is bringing two idears, whether simple or complex, together, and setting them by one another
so as to take a view of them at once, without uniting them into one, by which it gets all its ideas
of relations. 3. The third is separating them from all other ideas that accmpany them in there real
existence: this is called abstraction, and thus all its general ideas are made.

-- Jone Locke, An Essay Concerning Human Understanding (1690)

We are about to study the idea of computational process. Computational processes are abstract being
that inhabit computers. As they evolve, process manipulate other abstract things called data.
The evolution of a process in directed by a pattern of rules called a /programm/. People create
programs to direct processes. In effect, we conjure the spirits of the computer with our spells.

    A computaional process is indeed much like a sorcerer's idea of a spirit. It cannot be seen or
touched. It is composed of matter at all. However, it is very real. It can perform intellectual work.
It can answer questions. It can affect the world by disbursing money at a bank or by controlling 
a rebot arm in a factory. The programs we use to conjure processes are like a sorcerer's spell.
They are carefully composed from symbolic expressions in arcane and esoteric /programming languages/
that prescribe the tasks we want our processes to perform

**** The Elements of Programming

When we describe a language, we should pay particular attentation to the means that the language
provides for combining simple ideas to form more complex ideas. Every powerful language has three
mechanisms for accomplishing this:

- *primitive expressions*, which represent the simplest entities the language is concerned with,
- *means of combination*, by which compound elements are built from simpler ones, and
- *means of abstraction*, by which compund elements can be names and manipulated as units.

In programming, we deal with two kinds of elements: /procedures/ and /data/. (Later we will discover
that they are really not so distinct.)

***** Expressions

***** Naming and the Environment

#+BEGIN_SRC scheme
  (define size 2)
#+END_SRC

***** Evaluating Combinations
To evaluate a combination, do the follow:
- Evaluate the subexpressions of the combination.
- Apply the procedure that is the value of the leftmost subexpression (the operator) to the
  values of the other subexpressions (the operands).

***** Compound Procedures

We have identified in Lisp some of the elements that must appear in any powerful programming
language:

- Numbers and arithmetic operations are primitive data and procedures.
- Nesting of combinations provides a means of combining operations..
- Definitions that associate names with values provide a limited means of abstraction.

The general form of a *procedure definition* is 
#+BEGIN_SRC scheme
  (define (<name> <formal parameters>)
    <body>)
#+END_SRC

***** The Substitution Model for Procedure Application

To apply a compound procedure to arguments, evaluate the body of the procedure with each formal
parameter replaced by the corresponding argument.

Applicative order versus normal order

***** Conditional Expressions and Predicates
 
=cond= , which stands for "conditional"
#+BEGIN_SRC scheme
  (cond (<p1> <e1>)
        (<p2> <e1>)
        ...
        (<pn> <en>))
#+END_SRC

consisting of the symbol =cond= followed by parenthesized pais of expressions =(<p> <e>)=
called /clauses/. The first expression in each pair is a /predicate/-that is, and expression
whose value is interpreted as either true or false.

=else=, is a special symbol that can be used in place of =<p>= in the final clause of a =cond=
#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((<x 0) (-x))
          (else x)))
#+END_SRC

=if=
#+BEGIN_SRC scheme
  (if <predicate> <consequent> <alternative>)
#+END_SRC

- =and=, =or=, =not=
#+BEGIN_SRC scheme
  (and <e1> ... <en>)

  (or <e1> ... <en>)

  (not <e>)
#+END_SRC

****** Exercise
- 1.2
#+BEGIN_SRC scheme
  (/ (+ 5
        4
        (- 2
           (- 3
              (+ 6
                 (/ 4 5)))))
     (* 3
        (- 6 2)
        (- 2 7)))
#+END_SRC

- 1.3
#+BEGIN_SRC racket
  (define (sum-two-larger a b c)
    (cond ((and (> a b) (> c b)) (+ a c))
          ((and (> c a) (> b a)) (+ c b))
          ((and (> a c) (> b c)) (+ a b))))
  ;; test
  (sum-two-larger 1 2 3)
  (sum-two-larger 7 3 5)

  ;; another way
  (define (minimal-of-two a b)
    (if (> a b)
        b
        a))

  (define (sum-two-larger-2 a b c)
    (-  (+ a b c) (minimal-of-two a (minimal-of-two b c))))

  (sum-two-larger-2 1 2 3)
#+END_SRC

***** Example: Square Roots by Newton's Method

***** Procedures as Black-Box Abstractions

- Local Name

- Internal definitions and block structure


**** Procedures and the Processes They Generate   

***** 1.2.1 Linear Recursion and Iteration
sample, factorial function of n!

***** 1.2.2 Tree Recursion
Fibonacci number

***** 1.2.3 Orders of Grouth

***** 1.2.4 Exponentiation
b^3

***** 1.2.5. Greatest Common Divisior

***** 1.2.6 Example: Testing for Primality
- Fermat test
Fermat's Little Theorem:

**** Formulating Abstractions with Higher-Order Procedures

Procedures that manipulate procedures are called /higher-order procedures/. 

***** 1.3.1 Procedures as Arguments
#+BEGIN_SRC scheme
  (define (inc n) (+ n 1))
  (define (cube a) (* a a a))
  (define (sum-cubes a b)
    (+ cube a inc b))

  (sum-cubes 1 10)
#+END_SRC

***** 1.3.2 Constructing Procedures Using lambda
#+BEGIN_SRC scheme
  (lambda (<formal-parameters>) <body>)
#+END_SRC

In general, =lambda= is used to create procedures in the same way as =define= except that no
name is specified for the procedure

Like any expression that has a procedure as its values. a =lambda= expression can be used as 
the operator in a combination such as
#+BEGIN_SRC scheme
  ((lambda (x y z) (+ x y (square z)))
   1 2 3)

  12
#+END_SRC

Useing =let= to create local variable
#+BEGIN_SRC scheme
  (let ((<var1> <exp1>)
        (<var2> <exp2>)
        ...
        (<varn> <expn>))
    <body>)
#+END_SRC

***** 1.3.3 Procedures as General Methods

***** 1.3.4 Procedures as Returned Values
Sample
#+BEGIN_SRC scheme
  (define (average-damp f)
    (lambda (x) (average x (f x))))

  ((average-damp square) 10)
  55
#+END_SRC

*** Building Abstractions with Data
#+BEGIN_SRC scheme
  (define a 3)
  a
#+END_SRC

#+RESULTS:
: 3

